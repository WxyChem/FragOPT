import numpy as np
import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.DataStructs import ConvertToNumpyArray
from rdkit.Chem.Draw import SimilarityMaps


def morgan_from_one(smiles: str, radius: int, nbits: int):
    """
        Convert smiles to morgan fingerprint and record the bit information
    :param smiles: The input smiles
    :param radius: The radius parameter of morgan fingerprint
    :param nbits: The hash size parameter of morgan fingerprint
    :return:
    """
    mol = Chem.MolFromSmiles(smiles)

    bit_information = {}
    fingerprint = AllChem.GetMorganFingerprintAsBitVect(mol, radius, nbits, bitInfo=bit_information)
    fingerprint_array = np.zeros((1,), dtype=np.int8)
    ConvertToNumpyArray(fingerprint, fingerprint_array)

    return fingerprint_array, bit_information


def important_score(bit_numbers, importance: dict, bit_information: dict):
    """
        Get the importance score of each bit generated by morgan fingerprint.
    :param bit_numbers: The bit names
    :param importance: The shapley values for all bits.
    :param bit_information: The recorded morgan fingerprints information
    :return:
    """
    importance_information = {}

    for i, bit_number in enumerate(bit_numbers):
        if bit_number in bit_information:
            importance_information[bit_number] = importance[i]
        else:
            continue

    return importance_information


def atom_importance_score(smiles: str, bit_importance: dict, bit_information: dict, method: str = 'average'):
    """
        Mapping the importance score of bits on all atoms to get the contribution value of each atom in target molecule.
    :param method:
    :param smiles: The input molecular structures.
    :param bit_importance: The importance score of existed bits.
    :param bit_information: The bit information generated by morgan fingerprints.
    :return: Mapping the importance score of bits on all atoms
    """
    mol = Chem.MolFromSmiles(smiles)
    atom_score_dict = {atom.GetIdx(): 0.0 for atom in mol.GetAtoms()}
    keys_list = list(atom_score_dict.keys())

    # The average method for atom mapping
    if method == 'average':

        for bit, importance in bit_importance.items():
            importance = importance / len(bit_information[bit])

            for atom_idx, atom_range in bit_information[bit]:
                substructure_idxs = []

                for i in range(atom_idx - atom_range - 1, atom_idx + atom_range):

                    if (i + 1) in keys_list:
                        substructure_idxs.append(i + 1)

                contribution_value = importance / len(substructure_idxs)

                for sub_atom_idx in substructure_idxs:
                    atom_score_dict[sub_atom_idx] += contribution_value

    # The weighted by atomic mass for atom mapping
    elif method == 'weighted':

        for bit, importance in bit_importance.items():
            importance = importance / len(bit_information[bit])

            for atom_idx, atom_range in bit_information[bit]:
                total_mass = 0.0
                substructure_idxs = []
                substructure_atom_masses = []

                for i in range(atom_idx - atom_range - 1, atom_idx + atom_range):

                    if (i + 1) in keys_list:
                        substructure_idxs.append(i + 1)
                        atom = mol.GetAtomWithIdx(i + 1)
                        substructure_atom_masses.append(atom.GetMass())
                        total_mass = total_mass + atom.GetMass()

                for j, sub_atom_idx in enumerate(substructure_idxs):
                    atom_score_dict[sub_atom_idx] += importance * (substructure_atom_masses[j] / total_mass)

    importance_list = [value for _, value in atom_score_dict.items()]

    return atom_score_dict, importance_list


def add_atom_names_to_csv(csv_file, output_csv, atom_names):
    """
        Add atom name into csv file, and update the file.
    :param csv_file: the csv path of output file.
    :param output_csv:
    :param atom_names: atom list.
    """
    df = pd.read_csv(csv_file)
    if len(df) != len(atom_names):
        raise ValueError("The line number of CSV file dont pair to the number of atoms in smiles!")

    df['AtomName'] = atom_names
    df.to_csv(output_csv, index=False)


def extract_atoms_from_pdb(pdb_file, num_atoms):
    """
    get the atom name from PDB file.
    :param pdb_file: the file path of pdb file
    :param num_atoms:
    :return: atom list（for example：['O2', 'C1', ...]）
    """
    atom_names = []
    count = 0

    with open(pdb_file, 'r') as file:
        for line in file:
            if line.startswith("HETATM"):
                atom_name = line[12:17].strip()
                atom_names.append(atom_name)
                count += 1
                if count == num_atoms:
                    break

    if count < num_atoms:
        raise ValueError("The atoms in PDB file is less than in smiles!")

    return atom_names


def get_smiles_atom_count(smiles):
    """
    get the number of atoms
    :param smiles:
    :return: atoms number
    """
    mol = Chem.MolFromSmiles(smiles)
    num_atoms = mol.GetNumAtoms()
    return num_atoms


def generate_optimized_3d_structure(smiles, output_pdb):
    """
    Generate a 3D conformer for a molecule from SMILES, optimize its geometry using force field,
    and output the result as a PDB file.

    :param smiles: SMILES string of the molecule.
    :param output_pdb: Output PDB filename.
    """
    # Step 1: Create a molecule from SMILES
    mol = Chem.MolFromSmiles(smiles)
    mol = Chem.AddHs(mol)  # Add hydrogens

    # Step 2: Generate 3D coordinates using ETKDG method
    AllChem.EmbedMolecule(mol, AllChem.ETKDG())  # Embed with 3D coordinates

    # Step 3: Optimize the geometry using the UFF force field
    # AllChem.UFFOptimizeMolecule(mol)

    # Optional: If you want to use MMFF instead of UFF for optimization, use the following:
    AllChem.MMFFOptimizeMolecule(mol)

    # Step 4: Write the optimized molecule to a PDB file
    pdb_writer = Chem.rdmolfiles.PDBWriter(output_pdb)
    pdb_writer.write(mol)
    pdb_writer.close()

    print("3D structure saved to {}".format(output_pdb))


def redistribute_contribution(smiles, atom_score_dict):
    """
    For each atom in aromatic ring, calculate the atom contribution.

    :param smiles: input smiles.
    :param atom_score_dict: thedict for atom contribution.
    :return: update dict
    """
    mol = Chem.MolFromSmiles(smiles)
    aromatic_list = []
    aromatic_weighted_list = []
    reweighted_list = []

    for atom_idx, atom_weighted in atom_score_dict.items():
        atom = mol.GetAtomWithIdx(atom_idx)
        if atom.GetIsAromatic():
            aromatic_list.append(atom_idx)
            aromatic_weighted_list.append(atom_weighted)

    ssr = Chem.GetSymmSSSR(mol)
    for ring in ssr:
        total_weight = 0.0
        num_atoms = len(list(ring))

        for idx in list(ring):

            if idx in aromatic_list:
                total_weight = total_weight + aromatic_weighted_list[aromatic_list.index(idx)]

            else:
                break

        if idx not in aromatic_list:
            continue

        distribution_weight = total_weight / num_atoms

        for _ in range(0, num_atoms):
            reweighted_list.append(distribution_weight)

    if len(aromatic_list) == len(reweighted_list):
        for ai, rw in zip(aromatic_list, reweighted_list):
            atom_score_dict[ai] = rw
    else:
        print("Something wrong!")

    return atom_score_dict


def contribution_visualization(smiles: str, bit_numbers, importance: dict, image_path: str, weights_path: str,
                               morgan_hash_size: int, morgan_radius: int, color_map: str,
                               fig_size: tuple = (300, 300), dpi_value: int = 300, method: str="weighted", 
                               fig_save: bool = True, weights_save: bool = True):
    """
        Based on morgan fingerprints and shap method to calculate the importance of atoms, the weights was normalized
        by the shapley values. This importance score was relative importance.

    if you have question, please contact the author：Xiaoyan Wu, Email：wawdtam123@163.com

    :param weights_path:

    :param image_path:

    :param importance:

    :param bit_numbers:

    :param smiles: the structure of input molecule

    :param morgan_hash_size: default: 1024

    :param morgan_radius: default: 3

    :param color_map: default: 'seismic', Supporting color is displayed in color_list

    :param fig_size: default:(300, 300)

    :param dpi_value: default:300

    :return: None
    """
    fp, bit_info = morgan_from_one(smiles=smiles, radius=morgan_radius, nbits=morgan_hash_size)

    score = important_score(bit_numbers, importance, bit_info)

    atom_score_dict, atom_importance_list = atom_importance_score(smiles, score, bit_info, method=method)

    reweighted_atom_score_dict = redistribute_contribution(smiles=smiles, atom_score_dict=atom_score_dict)

    importance_list = [value for _, value in reweighted_atom_score_dict.items()]

    atom_nums = []
    atom_weights = []

    for k, v in reweighted_atom_score_dict.items():
        atom_nums.append(k)
        atom_weights.append(v)
    
    if weights_save:
        data = pd.DataFrame()
        data['atom_idx'] = atom_nums
        data['atom_weights'] = atom_weights
        data.to_csv(weights_path, index=False)
    
    if fig_save:
        mol = Chem.MolFromSmiles(smiles)
        weights = SimilarityMaps.GetStandardizedWeights(importance_list)
        fig = SimilarityMaps.GetSimilarityMapFromWeights(mol, weights=weights[0], colorMap=color_map, size=fig_size)
        fig.savefig(image_path, bbox_inches='tight', dpi=dpi_value)
    
    return atom_nums, atom_weights
    